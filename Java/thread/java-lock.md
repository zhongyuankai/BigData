# 对锁的一些认知 有哪些锁

## 同一进程

### 公平锁和非公平锁
公平锁：就是很公平，在并发的环境中，每个线程在获取锁时会先查看锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。

非公平锁：比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。

`ReentrantLock` 通过构造函数指定该锁是否是公平锁 ,默认是非公平锁 非公平锁的优点在于吞吐量比公平锁大.

`synchronized`也是一种非公平锁.


### 重入锁
ReentrantLock/synchronized就是一个典型的可重入锁;

使用 `ReentrantLock` 获取锁的时候会判断当前线程是否为获取锁的线程，如果是则将同步的状态 +1 ,释放锁的时候则将状态 -1。只有将同步状态的次数置为 0 的时候才会最终释放锁。

### 自旋锁
指尝试获取锁的线程不会立即阻塞，而是**采用循环的方式去尝试获取锁**，这样做的好处是减少上下文的切换；

```java
public final int getAndAddInt(Object paramObject, long paramLong, int paramInt)
{
  int i;
  do
    i = getIntVolatile(paramObject, paramLong);
  while (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));
  return i;
}
```

### 独占锁、共享锁

独占锁：指该锁一次只能被一个线程持有。对ReentrantLock和Synchronized而言都是独占锁；

共享锁：指该锁可被多个线程持有。对ReentrantReadWriterLock其读锁是共享锁，其写锁是独占锁。

### 读写锁
使用 `ReentrantReadWriteLock` ,同时维护一对锁：读锁和写锁。当写线程访问时则其他所有锁都将阻塞，读线程访问时则不会。通过读写锁的分离可以很大程度的提高并发量和吞吐量。


## 不同进程

分布式锁：

### 基于数据库
可以创建一张表，将其中的某个字段设置为`唯一索引`，当多个请求过来的时候只有新建记录成功的请求才算获取到锁，当使用完毕删除这条记录的时候即释放锁。

存在的问题:
- 数据库单点问题，挂了怎么办？
- 不是重入锁，同一进程无法在释放锁之前再次获得锁，因为数据库中已经存在了一条记录了。
- 锁是非阻塞的，一旦 `insert` 失败则会立即返回，并不会进入阻塞队列只能下一次再次获取。
- 锁没有失效时间，如果那个进程解锁失败那就没有请求可以再次获取锁了。

解决方案:
- 数据库切换为主从，不存在单点。
- 在表中加入一个同步状态字段，每次获取锁的是加 1 ，释放锁的时候`-1`，当状态为 0 的时候就删除这条记录，即释放锁。
- 非阻塞的情况可以用 `while` 循环来实现，循环的时候记录时间，达到 X 秒记为超时，`break`。
- 可以开启一个定时任务每隔一段时间扫描找出多少 X 秒都没有被删除的记录，主动删除这条记录。

### 基于 Redis

利用 Redis set key 时的一个 NX 参数可以保证在这个 key 不存在的情况下写入成功。并且再加上 EX 参数可以让该 key 在超时之后自动删除，这样也可以避免死锁；

可以参考：[基于 Redis 的分布式锁](https://crossoverjie.top/2018/03/29/distributed-lock/distributed-lock-redis/)

### 基于 ZK

分布式锁算法流程如下：

- 客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推；
- 客户端获取/lock下的子节点列表，**判断自己创建的子节点是否为当前子节点列表中序号最小的子节点**，如果是则认为获得锁，否则**监听刚好在自己之前一位的子节点删除消息**，获得子节点变更通知后重复此步骤直至获得锁；
- 执行业务代码；
- 完成业务流程后，删除对应的子节点释放锁；

可以参考：[基于 ZK 的分布式锁](https://blog.csdn.net/qiangcuo6087/article/details/79067136)
